<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head>

<title>consequently.org: Logic Text Chapter 9 Solutions</title><link type="text/css" rel="stylesheet" href="style.css" /><meta name="robots" content="INDEX,NOFOLLOW" /></head>
<body>

<h1>Logic Text Chapter 9 Solutions</h1>
<div class="content browse"><h2>Chapter 9: Models for Predicate Logic</h2><h3>Basic</h3><p><i>Question {9.1}</i></p><p>1. True. (Each instance is true.)</p><p>2. True. (Each instance is true.)</p><p>3. False. It has a false instance, <i>b</i> for <i>x</i> and <i>a</i> for <i>y</i>, <i>Tba</i> &#x2283; (<i>Tab</i> &amp; ~ <i>Fb</i>)) is false.</p><p>4. True. It has a true instance (&#x2200; <i>y</i>)((<i>Tby</i> &amp; <i>Fy</i>) &#x2283; (<i>Gb</i> &amp; <i>Tby</i>))</p><p>5. False. It has a false instance (<i>a</i> for <i>x</i> and <i>b</i> for <i>y</i>) (&#x2203; <i>z</i>)(<i>Taz</i> &amp; <i>Tab</i>) &#x2283; (&#x2203; <i>z</i>)(<i>Tbz</i> &amp; <i>Tza</i>)</p><p>The antecedent is true as it has a true instance (<i>b</i> for <i>z</i>). The consequent is false as it has no true instance.</p><p><i>Question {9.2}</i></p><p>Formulas 3, 4, 5, 6, 8, 9 and 10 are true. The rest are false.</p><p><i>Question {9.3}</i></p><p>2, 3, 4, 6, 7, 8 and 10 are tautologies. They are true in every two-element model (and in <i>every</i> model, in fact!)</p><p>Number 1 is false in this model:</p><p><i>D</i> = {a,b}</p><table class="user"><tr><td align="right"></td><td align="center"><i>I</i>(<i>F</i>)</td><td align="center"><i>I</i>(<i>G</i>)</td></tr><tr><td align="center">a </td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">b </td><td align="center">1</td><td align="center">1</td></tr></table><p>(&#x2200; <i>x</i>)(<i>Fx</i> &#x2283; <i>Gx</i>) &#x2228; (&#x2200; <i>x</i>)(<i>Fx</i> &#x2283; ~ <i>Gx</i>) is false, as (&#x2200; <i>x</i>)(<i>Fx</i> &#x2283; <i>Gx</i>) is false (it has a false instance: <i>Fa</i> &#x2283; <i>Ga</i>) and (&#x2200; <i>x</i>)(<i>Fx</i> &#x2283; ~ <i>Gx</i>) is false (it has a false instance: <i>Fa</i> &#x2283; ~ <i>Ga</i>)</p><p>The rest are false in this model:</p><p><i>D</i> = {a,b}</p><table class="user"><tr><td align="right"></td><td align="center"><i>I</i>(<i>F</i>)</td></tr><tr><td align="center">a </td><td align="center">0</td></tr><tr><td align="center">b </td><td align="center">1</td></tr></table><p>5: (&#x2200; <i>x</i>)<i>Fx</i> &#x2228; (&#x2200; <i>x</i>)~ <i>Fx</i> is false, as both (&#x2200; <i>x</i>)<i>Fx</i> and (&#x2200; <i>x</i>)~ <i>Fx</i> are false.</p><p>9: (&#x2200; <i>x</i>)(<i>Fx</i> &#x2283; (&#x2200; <i>y</i>)<i>Fy</i>) is false, as it has a false instance <i>Fb</i> &#x2283; (&#x2200; <i>y</i>)<i>Fy</i>, as (&#x2200; <i>y</i>)<i>Fy</i> is false, but <i>Fb</i> is true.</p><p><i>Question {9.4}</i></p><p>Arguments 3, 5, 6, 7 and 8 are valid. The rest are invalid.</p><p>1 has the following counterexample:</p><p><i>D</i> = {a,b,c}</p><table class="user"><tr><td align="right"></td><td align="center"><i>I</i>(<i>G</i>)</td><td align="center"><i>I</i>(<i>H</i>)</td></tr><tr><td align="center">a </td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">b </td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">c </td><td align="center">0</td><td align="center">0</td></tr></table><p>(&#x2200; <i>x</i>)(<i>Gx</i> &#x2283; <i>Hx</i>) is true as every instance is true. (&#x2200; <i>x</i>)(~ <i>Gx</i> &#x2283; ~ <i>Hx</i>) is false as the instance ~ <i>Gb</i> &#x2283; ~ <i>Hb</i> is false.</p><p>2 has the following counterexample:</p><p><i>D</i> = {a,b,c}</p><table class="user"><tr><td align="right"></td><td align="center"><i>I</i>(<i>G</i>)</td><td align="center"><i>I</i>(<i>H</i>)</td></tr><tr><td align="center">a </td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">b </td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">c </td><td align="center">0</td><td align="center">0</td></tr></table><p>(&#x2200; <i>x</i>)<i>Gx</i> &#x2283; (&#x2200; <i>x</i>)<i>Hx</i> is true, as (&#x2200; <i>x</i>)<i>Gx</i> and (&#x2200; <i>x</i>)<i>Hx</i> are both false. However, (&#x2200; <i>x</i>)(<i>Gx</i> &#x2283; <i>Hx</i>) is not true, as it has a false instance: <i>Gb</i> &#x2283; <i>Hb</i>.</p><p>4 has the following counterexample:</p><p><i>D</i> = {a,b,c}</p><table class="user"><tr><td align="right"></td><td align="center"><i>I</i>(<i>G</i>)</td><td align="center"><i>I</i>(<i>H</i>)</td></tr><tr><td align="center">a </td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">b </td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">c </td><td align="center">1</td><td align="center">1</td></tr></table><p>(&#x2203; <i>x</i>)(<i>Gx</i> &#x2261; <i>Hx</i>) is true, it has a true instance with <i>a</i> for <i>x</i>. But ~(&#x2200; <i>x</i>)(<i>Gx</i> &#x2283; <i>Hx</i>) is false, as (&#x2200; <i>x</i>)(<i>Gx</i> &#x2283; <i>Hx</i>) is true.</p><p>9 has the following counterexample:</p><p><i>D</i> = {a,b,c}</p><table class="user"><tr><td align="right"></td><td align="center"><i>I</i>(<i>G</i>)</td><td align="center"><i>I</i>(<i>H</i>)</td></tr><tr><td align="center">a </td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">b </td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">c </td><td align="center">0</td><td align="center">0</td></tr></table><p>(&#x2200; <i>x</i>)(<i>Gx</i> &#x2283; ~ <i>Hx</i>) is true, as every instance is true. (Every instance of <i>Gx</i> is false, so the conditional is always true!). However, no instance of (&#x2203; <i>x</i>)(<i>Gx</i> &amp; ~ <i>Hx</i>) is true (for the same reason: <i>Gx</i> is never true).</p><p>10 has the following counterexample:</p><p><i>D</i> = {a,b,c}</p><table class="user"><tr><td align="right"></td><td align="center"><i>I</i>(<i>G</i>)</td><td align="center"><i>I</i>(<i>H</i>)</td></tr><tr><td align="center">a </td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">b </td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">c </td><td align="center">0</td><td align="center">0</td></tr></table><p>(&#x2203; <i>x</i>)(<i>Gx</i> &amp; ~ <i>Hx</i>) is now true. However ~(&#x2200; <i>x</i>)(<i>Gx</i> &#x2283; ~ <i>Hx</i>) is false, as (&#x2200; <i>x</i>)(<i>Gx</i> &#x2283; ~ <i>Hx</i>) is true.</p><p><i>Question {9.5}</i></p><p>Each of the three names can pick out any of the four objects. So for each name you have four choices. The result is 4 x 4 x 4 = 16 x 4 = 64 different assignments of objects to names. In general, with <i>n</i> names and <i>m</i> objects, you gave <i>m</i> x <i>m</i> x &#x2026; x <i>m</i> (<i>n</i> times) = <i>m</i> to the power of <i>n</i>.</p><p><i>Question {9.6}</i></p><p>Given a three place predicate in a domain of 2 objects, you have a 2 x 2 x 2 table (think of a cube) to fill with values of either 0 or 1. That is, you have 8 slots to fill in with either 0 or 1, and there are 2 to the power of 8, namely 256, different ways of doing this. In general, for an <i>n</i> place predicate in a domain of <i>m</i> objects, you have a staggering 2 to the power of (<i>m</i> to the power of <i>n</i>) ways of doing this. That&#x2019;s a <b>lot</b> of different combinations!</p><p><i>Question {9.7}</i></p><p>This is a hard one.</p><ul><li><i>n</i> names can be done <i>k</i>^<i>n</i> times (I write ``<i>k</i> to the <i>n</i>’’ as ``<i>k</i>^<i>n</i>’’.)</li><li><i>m</i> monadic predicates can be done (2^<i>k</i>)^<i>m</i> times.</li><li><i>j</i> dyadic predicates can be done (2^(<i>k</i>^2))^<i>j</i> times.</li></ul><p>This gives you <i>k</i>^<i>n</i> x (2^<i>k</i>)^<i>m</i> x (2^(<i>k</i>^2))^<i>j</i> different models all up. That&#x2019;s a lot!</p><p><i>Question {9.8}</i></p><p>Here is a formula which is satisfied only in a model with an infinite domain </p><p>(&#x2200; <i>x</i>)~ <i>Sxx</i> &amp; (&#x2200; <i>x</i>)(&#x2200; <i>y</i>)(&#x2200; <i>z</i>)((<i>Sxy</i> &amp; <i>Syz</i>) &#x2283; <i>Sxz</i>) &amp; (&#x2200; <i>x</i>)(&#x2203; <i>y</i>)<i>Sxy</i></p><p>Why? Well, first show that it has a model with an infinite domain. In particular, it has a model with the domain <i>D</i> = {0,1,2,3,4,&#x2026;} of all the numbers. Interpret <i>S</i> like this: <i>Sxy</i> holds when <i>x</i> is smaller than <i>y</i>. So, it has a table like this </p><table class="user"><tr><td align="center">I(S)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">… </td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">&#x2026;</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">&#x2026;</td></tr><tr><td align="center">2</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">&#x2026;</td></tr><tr><td align="center">3</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">&#x2026;</td></tr><tr><td align="center">… </td><td align="center">… </td><td align="center">… </td><td align="center">… </td><td align="center">… </td><td align="center">… </td><td align="center">&#x2026;</td></tr></table><p>And the formula is true in this interpretation, as (1) no number is smaller than itself (2) If one number is smaller than another, and that number is smaller than a third, then the first is smaller than the third. (3) For any number, there&#x2019;s a bigger number.</p><p>So, the whole formula is true in this model with an infinite domain.</p><p>Now we&#x2019;ll show that in any finite model, this whole formula is false. In particular, we&#x2019;ll show that if the second and third conjuncts are true, then the first conjunct (&#x2200; <i>x</i>)~ <i>Sxx</i> is false.</p><p>Suppose you&#x2019;ve got a finite domain and you want to make (&#x2200; <i>x</i>)(&#x2203; <i>y</i>)<i>Sxy</i> true in it. This means that every object in the domain is &#x201c;smaller than&#x201d; some object in the domain. Now suppose that (&#x2200; <i>x</i>)(&#x2200; <i>y</i>)(&#x2200; <i>z</i>)((<i>Sxy</i> &amp; <i>Syz</i>) &#x2283; <i>Sxz</i>) is true. This means that if <i>x</i> is &#x201c;smaller than&#x201d; <i>y</i> and <i>y</i> is &#x201c;smaller than&#x201d; <i>z</i> then <i>x</i> is &#x201c;smaller than&#x201d; <i>z</i>.</p><p>Now look at what happens if these hold in a finite domain. Start with one object. It must be &#x201c;smaller than&#x201d; some object. If it is &#x201c;smaller than&#x201d; itself, we&#x2019;re done: we&#x2019;ve made (&#x2200; <i>x</i>)~ <i>Sxx</i> false. So, suppose it&#x2019;s &#x201c;smaller than&#x201d; something else. So, we&#x2019;ve got a picture like this:</p><table class="user"><tr><td align="center">a </td><td align="center">&#x2014;S&#x2192; </td><td align="center">b </td></tr></table><p>Now b is &#x201c;smaller than&#x201d; some object too. If we have <i>Sba</i>, then since <i>Sab</i> and <i>Sba</i>, we must have <i>Saa</i>, which conflicts with (&#x2200; <i>x</i>)~ <i>Sxx</i>. If we have <i>Sbb</i>, this is bad too, so we must have a new object c, such that <i>Sbc</i>. So, we&#x2019;ve got a picture like this:</p><table class="user"><tr><td align="center">a </td><td align="center">&#x2014;S&#x2192; </td><td align="center">b </td><td align="center">&#x2014;S&#x2192; </td><td align="center">c </td></tr></table><p>Now we have <i>Sac</i> too (since <i>Sab</i> and <i>Sbc</i>) so the picture is actually like this:</p><table class="user"><tr><td align="center">a </td><td align="center">&#x2014;S&#x2192; </td><td align="center">b </td><td align="center">&#x2014;S&#x2192; </td><td align="center">c </td></tr><tr><td align="center">|</td><td align="right"></td><td align="right"></td><td align="right"></td><td align="center">|</td></tr><tr><td align="right"></td><td align="center">&#x2014;</td><td align="center">-S-</td><td align="center">&#x2192; </td><td align="right"></td></tr></table><p>Now, there must be some object <i>y</i> where <i>Scy</i>: what could it be? If it were <i>a</i>, then we&#x2019;d have <i>Sac</i> and <i>Sca</i>, and so, <i>Saa</i>, which is bad. If it were <i>b</i>, we&#x2019;d have <i>Sbc</i> and <i>Scb</i>, which gives <i>Sbb</i>, which is bad. If it were <i>c</i>, we&#x2019;d have <i>Scc</i>, which is bad too. So, we need a new object <i>d</i> where <i>Scd</i>.</p><p>This goes on forever. Every object requires a <i>new</i> object to be related to by <i>S</i>, because (&#x2200; <i>x</i>)~ <i>Sxx</i> requires that we can&#x2019;t have <i>S</i> &#x201c;looping back&#x201d; to anywhere it&#x2019;s already been. So, our formula can only be true in an infinite domain. No finite list of objects will be enough.</p><p>So, we can answer our original question:</p><p>The formula </p><p>~[ (&#x2200; <i>x</i>)~ <i>Sxx</i> &amp; (&#x2200; <i>x</i>)(&#x2200; <i>y</i>)(&#x2200; <i>z</i>)((<i>Sxy</i> &amp; <i>Syz</i>) &#x2283; <i>Sxz</i>) &amp; (&#x2200; <i>x</i>)(&#x2203; <i>y</i>)<i>Sxy</i> ]</p><p>is true in every finite model, and it is false in some infinite models.</p></div>
</body>
</html>

